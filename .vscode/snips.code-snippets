{
  "temp_simple": {
    "prefix": "simple",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "bool global_use_debug = false;",
      "#define use_debug global_use_debug = true;",
      "#define debug if (global_use_debug)",
      "using namespace std;",
      "#define vec(type) vector<type>",
      "#define sz(cont) (ll) size(cont)",
      "#define of :",
      "#define endl \"\\n\"",
      "#define ll long long",
      "#define all(vec) vec.begin(), vec.end()",
      "#define rall(vec) vec.rbegin(), vec.rend()",
      "#define rv(x) return void(cout << x << endl)",
      "void using_local()",
      "{",
      "    ifstream myfile;",
      "    myfile.open(\"hamza_local\");",
      "    if (myfile)",
      "    {",
      "        use_debug;",
      "        freopen(\"input\", \"r\", stdin), freopen(\"output\", \"w\", stdout);",
      "    }",
      "}",
      "",
      "template <typename T>",
      "istream &operator>>(istream &in, vector<T> &into)",
      "{",
      "    int n = into.size();",
      "    for (int i = 0; i < n; i++)",
      "        in >> into[i];",
      "",
      "    return in;",
      "}",
      "template <typename T>",
      "ostream &operator<<(ostream &out, vector<T> &outto)",
      "{",
      "    int n = outto.size();",
      "    for (int i = 0; i < n; i++)",
      "        out << outto[i] << \" \";",
      "    return out;",
      "}",
      "",
      "void test_case()",
      "{",
      "   $1",
      "}",
      "",
      "int main()",
      "{",
      "    ios_base::sync_with_stdio(false), cout.tie(0), cin.tie(0);",
      "    using_local();",
      "",
      "    int tc = 1;",
      "",
      "    cin >> tc;",
      "",
      "    while (tc--)",
      "    {",
      "        test_case();",
      "    }",
      "}",
      ""
    ],
    "description": "simple_temp"
  },
  "temp": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <iomanip>",
      "#include <chrono>",
      "using namespace std;",
      "using std::chrono::duration;",
      "using std::chrono::duration_cast;",
      "using std::chrono::high_resolution_clock;",
      "using std::chrono::milliseconds;",
      "",
      "bool global_use_clock = false;",
      "bool global_use_test_case = false;",
      "bool global_use_debug = false;",
      "#define use_double(num)        \\",
      "    cout << setprecision(num); \\",
      "    cout << fixed;",
      "#define use_debug global_use_debug = true;",
      "#define use_clock global_use_clock = true;",
      "#define use_test_case global_use_test_case = true;",
      "#define sp << \" \" <<",
      "#define spe << \" \"",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef vector<ll> vec;",
      "typedef deque<ll> deq;",
      "typedef vector<ull> vecull;",
      "typedef vector<pair<ll, ll>> vecp;",
      "typedef vector<vector<ll>> vecv;",
      "typedef vector<set<ll>> vecset;",
      "typedef vector<string> vecstr;",
      "typedef pair<ll, ll> pl;",
      "typedef map<ll, ll> mpll;",
      "#define vec(type) vector<type>",
      "#define deq(type) deque<type>",
      "ll OO = 1e9;",
      "ll OOO = 1e18;",
      "ull MOD = 1e9 + 7;",
      "ull MOD2 = 998244353;",
      "#define sz(cont) (ll) size(cont)",
      "#define of :",
      "#define endl \"\\n\"",
      "#define null nullptr",
      "#define NO return void(cout << \"NO\" << endl)",
      "#define YES return void(cout << \"YES\" << endl)",
      "#define no return void(cout << \"no\" << endl)",
      "#define yes return void(cout << \"yes\" << endl)",
      "#define No return void(cout << \"No\" << endl)",
      "#define Yes return void(cout << \"Yes\" << endl)",
      "#define all(vec) vec.begin(), vec.end()",
      "#define rall(vec) vec.rbegin(), vec.rend()",
      "#define forn(i, init, n) for (ll i = init; i < n; ++i)",
      "#define forr(i, init, n) for (ll i = init; i > n; --i)",
      "#define negMod(n, m) (n % m + m) % m",
      "#define rv(exp) return void(cout << exp << endl)",
      "#define str string",
      "#define cnt_set_bits __builtin_popcount",
      "#define maxHeap(type) priority_queue<type, vector<type>, less<type>>",
      "#define minHeap(type) priority_queue<type, vector<type>, greater<type>>",
      "#define use_getline cin.ignore(std::numeric_limits<std::streamsize>::max(), \"\\n\")",
      "#define rt return",
      "#define debug if (global_use_debug)",
      "bool by_len(string &a, string b)",
      "{",
      "    return a.size() < b.size();",
      "}",
      "#define sep               \\",
      "    if (global_use_debug) \\",
      "        cout << \"===================================\" << endl;",
      "template <typename T>",
      "istream &operator>>(istream &in, vector<T> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        in >> into[i];",
      "",
      "    return in;",
      "}",
      "template <typename T>",
      "ostream &operator<<(ostream &out, vector<T> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "        out << outto[i] << \" \";",
      "    return out;",
      "}",
      "void FastIO()",
      "{",
      "    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);",
      "}",
      "void using_local()",
      "{",
      "    ifstream myfile;",
      "    myfile.open(\"hamza_local\");",
      "    if (myfile)",
      "    {",
      "        use_debug;",
      "        freopen(\"input\", \"r\", stdin), freopen(\"output\", \"w\", stdout);",
      "    }",
      "}",
      "",
      "void test_case(int case_num)",
      "{",
      "    /*",
      "        READ->",
      "",
      "        THINK->",
      "           $1",
      "        CODE",
      "    */",
      "     $2",
      "}",
      "void pre_init()",
      "{",
      "    FastIO();",
      "    using_local();",
      "",
      "    use_test_case;",
      "    debug use_test_case;",
      "}",
      "int main()",
      "{",
      "",
      "    auto t1 = high_resolution_clock::now();",
      "    ll tc = 1;",
      "    pre_init();",
      "    if (global_use_test_case)",
      "        cin >> tc;",
      "    for (int i = 1; i <= tc; i++)",
      "        test_case(i);",
      "    auto t2 = high_resolution_clock::now();",
      "",
      "    duration<double, std::milli> ms_double = t2 - t1;",
      "    if (global_use_clock && global_use_debug)",
      "        cout << ms_double.count() << \"ms\\n\";",
      "}",
      ""
    ],
    "description": "temp"
  },
  "forn": {
    "prefix": "forn",
    "body": "forn($1, $2, $3 ) { $4 }",
    "description": "loop"
  },
  "forr": {
    "prefix": "forr",
    "body": "forr($1 , $2,$3) { $4 }",
    "description": "loop"
  },
  "adj": {
    "prefix": "adj",
    "body": "map<ll,vec> adj;"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "const ull N = 1e6 + 5;",
      "bool prime[N];",
      "void sieve()",
      "{",
      "    memset(prime, true, sizeof(prime));",
      "    prime[1] = false;",
      "    prime[0] = false;",
      "    for (int p = 2; p * p < N; p++)",
      "    {",
      "        if (prime[p] == true)",
      "        {",
      "",
      "            for (int i = p * p; i < N; i += p)",
      "                prime[i] = false;",
      "        }",
      "    }",
      "}"
    ],
    "description": "sieve"
  },
  "tprime": {
    "prefix": "tprime",
    "body": [
      "bool tprime(ll num)",
      "{",
      "    double y = sqrt(num);",
      "    ll x = sqrt(num);",
      "    return prime[x] && y == x;",
      "}",
      ""
    ],
    "description": "tprime"
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "ll gcd(ll a, ll b)",
      "{",
      "    if (a == 0)",
      "        return b;",
      "    return gcd(b % a, a);",
      "}",
      ""
    ],
    "description": "gcd"
  },
  "gcdAll": {
    "prefix": "gcdAll",
    "body": [
      "ll gcdAll(vector<ll> &nums, int from = 0)",
      "{",
      "    ll n = sz(nums);",
      "    ll cur = nums[from];",
      "    for (ll i = from + 1; i < n; i++)",
      "    {",
      "        cur = gcd(cur, nums[i]);",
      "    }",
      "    return cur;",
      "}"
    ],
    "description": "gcdAll"
  },
  "all Equal": {
    "prefix": "all_equal",
    "body": [
      "bool all_equal(vector<ll> &nums, int from = 0)",
      "{",
      "    int n = sz(nums);",
      "    ll cur = nums[from];",
      "    for (ll i = from + 1; i < n; i++)",
      "    {",
      "        if (cur != nums[i])",
      "            return false;",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "all Equal"
  },
  "sigma": {
    "prefix": "sigma",
    "body": ["ull sigma(ull x)", "{", "    return x * (x + 1) / 2;", "}"],
    "description": "sigma"
  },
  "sum_num": {
    "prefix": "sum_num",
    "body": [
      "ll sum_num(ll n)",
      "{",
      "    ll sum = 0;",
      "    while (n > 0)",
      "    {",
      "        sum += (n % 10);",
      "        n /= 10;",
      "    }",
      "    return sum;",
      "}"
    ],
    "description": "sum_num"
  },
  "custom_pow": {
    "prefix": "custom_pow",
    "body": [
      "ull custom_pow(ull a, ull b)",
      "{",
      "    ull res = 1;",
      "    while (b--)",
      "        res *= a;",
      "",
      "    return res;",
      "}"
    ],
    "description": "custom_pow"
  },
  "custom_log": {
    "prefix": "custom_log",
    "body": [
      "ll custom_log(ll a, ll b)",
      "{",
      "    return log2(a) / log2(b);",
      "}"
    ],
    "description": "custom_log"
  },
  "primeFactors": {
    "prefix": "primeFactors",
    "body": [
      "vec primeFactors(ll n)",
      "{",
      "    vec factors;",
      "    while (n % 2 == 0)",
      "    {",
      "        factors.push_back(2);",
      "        n = n / 2;",
      "    }",
      "",
      "    for (ll i = 3; i*i <= n; i = i + 2)",
      "    {",
      "        while (n % i == 0)",
      "        {",
      "            factors.push_back(i);",
      "            n = n / i;",
      "        }",
      "    }",
      "",
      "    if (n > 2)",
      "        factors.push_back(n);",
      "",
      "    return factors;",
      "}",
      ""
    ],
    "description": "primeFactors"
  },
  "max": {
    "prefix": "max",
    "body": [
      "ll max(vector<ll> &nums)",
      "{",
      "    int n = size(nums);",
      "    ll mx = -OO;",
      "    for (ll i = 0; i < n; i++)",
      "    {",
      "        mx = max(mx, nums[i]);",
      "    }",
      "    return mx;",
      "}"
    ],
    "description": "max"
  },
  "min": {
    "prefix": "min",
    "body": [
      "ll min(vector<ll> &nums)",
      "{",
      "    int n = size(nums);",
      "    ll mn = OO;",
      "    for (ll i = 0; i < n; i++)",
      "    {",
      "        mn = min(mn, nums[i]);",
      "    }",
      "    return mn;",
      "}"
    ],
    "description": "min"
  },
  "fact": {
    "prefix": "fact",
    "body": [
      "ull fact(ull x)",
      "{",
      "    ull res = 1;",
      "    while (x > 0)",
      "        res *= x--;",
      "",
      "    return res;",
      "}"
    ],
    "description": "min"
  },
  "count_bin_ones": {
    "prefix": "count_bin_ones",
    "body": [
      "ll count_bin_ones(ll n)",
      "{",
      "    int c = 0;",
      "    int i = 1;",
      "    while (n)",
      "    {",
      "        if (n & 1)",
      "            c++;",
      "        n = n >> 1;",
      "    }",
      "    return c;",
      "}"
    ],
    "description": "count_bin_ones"
  },
  "bitMaskInit": {
    "prefix": "bitMaskInit",
    "body": [
      "int bitMaskFirst(string s)",
      "{",
      "    const int N = s.size();",
      "    int MAX = 1 << N;",
      "    for (int mask = 1; mask < MAX; mask++)",
      "    {",
      "        string subSq = \"\";",
      "        for (int i = 0; i < N; i++)",
      "        {",
      "            if (mask & (1 << i))",
      "                subSq += s[i];",
      "        }",
      "    }",
      "}"
    ],
    "description": "bitMaskInit"
  },
  "num_len": {
    "prefix": "num_len",
    "body": [
      "ll num_len(ll n)",
      "{",
      "    ll res = 0;",
      "    while (n)",
      "    {",
      "        res++;",
      "        n /= 10;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "bitMaskInit"
  },
  "acc": {
    "prefix": "acc",
    "body": [
      "ull acc(vec &nums)",
      "{",
      "    ull sum = 0;",
      "    for (int i = 0; i < nums.size(); i++)",
      "    {",
      "        sum += nums[i];",
      "    }",
      "    return sum;",
      "}"
    ],
    "description": "acc"
  },
  "sigmaSquared": {
    "prefix": "sigmaSquared",
    "body": [
      "ull sigmaSquared(ull x)",
      "{",
      "    return (((x * ((x + 1))) * (((x * 2) + 1)))) / 6;",
      "}"
    ],
    "description": "sigmaSquared"
  },
  "gen_palands": {
    "prefix": "gen_palands",
    "body": [
      "int createPalindrome(int input, int b, bool isOdd)",
      "{",
      "    int n = input;",
      "    int palin = input;",
      "",
      "    if (isOdd)",
      "        n /= b;",
      "",
      "    while (n > 0)",
      "    {",
      "        palin = palin * b + (n % b);",
      "        n /= b;",
      "    }",
      "    return palin;",
      "}",
      "vec palands;",
      "void generatePalindromes(int n)",
      "{",
      "    int number;",
      "",
      "    for (int j = 0; j < 2; j++)",
      "    {",
      "        int i = 1;",
      "        while ((number = createPalindrome(i, 10, j % 2)) < n)",
      "        {",
      "            palands.push_back(number);",
      "            i++;",
      "        }",
      "    }",
      "}"
    ],
    "description": "gen_palands"
  },
  "get_freq": {
    "prefix": "get_freq",
    "body": [
      "void get_freq(vec &arr, str s)",
      "{",
      "    for (const char ch of s)",
      "        arr[ch - 'a']++;",
      "}"
    ],
    "description": "get_freq"
  },
  "bs_sqrt": {
    "prefix": "bs_sqrt",
    "body": [
      "ll bs_sqrt(ll x)",
      "{",
      "    ll left = 0, right = 2000000123;",
      "    while (right > left)",
      "    {",
      "        ll mid = (left + right) / 2;",
      "",
      "        if (mid * mid > x)",
      "            right = mid;",
      "        else",
      "            left = mid + 1;",
      "    }",
      "    return left - 1;",
      "}",
      ""
    ],
    "description": "bs_sqrt"
  },
  "isprime": {
    "prefix": "isprime",
    "body": [
      "ll mpow(ll n, ll p, ll m)",
      "{",
      "    if (!p)",
      "        return 1;",
      "    else if (p & 1)",
      "        return (n * mpow(n, p - 1, m)) % m;",
      "    else",
      "    {",
      "        ll v = mpow(n, p / 2, m);",
      "        return (v * v) % m;",
      "    }",
      "}",
      "bool isprime(ll n)",
      "{",
      "    if (n < 2)",
      "        return false;",
      "    for (ll i = 2; i * i * i <= n; ++i)",
      "        if (n % i == 0)",
      "            return false;",
      "    for (int it = 0; it < 1e5; ++it)",
      "    {",
      "        ll i = rand() % (n - 1) + 1;",
      "        if (__gcd(i, n) != 1)",
      "            return false;",
      "        if (mpow(i, n - 1, n) != 1)",
      "            return false;",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "isprime"
  },
  "is_prime": {
    "prefix": "is_prime",
    "body": [
      "bool is_prime(ull n)",
      "{",
      "    // Check if a number is prime",
      "    if (n <= 1)",
      "        return false;",
      "    for (ull i = 2; i * i <= n; i++)",
      "        if (n % i == 0)",
      "            return false;",
      "    return true;",
      "}"
    ],
    "description": "is_prime"
  },
  "": {
    "prefix": "mod_inv",
    "body": [
      "ll fast_pow(ll a, ll b)",
      "{",
      "    a %= MOD;",
      "    if (a == 0)",
      "        return 0;",
      "    ll product = 1;",
      "    while (b > 0)",
      "    {",
      "        if (b & 1)",
      "        {",
      "            product *= a;",
      "            product %= MOD;",
      "            --b;",
      "        }",
      "        a *= a;",
      "        a %= MOD;",
      "        b /= 2;",
      "    }",
      "    return product;",
      "}",
      "ll mod_inv(ll a)",
      "{",
      "    return fast_pow(a, MOD - 2);",
      "}"
    ],
    "description": ""
  },
  "fast_pow": {
    "prefix": "fast_pow",
    "body": [
      "ll fast_pow(ll a, ll b)",
      "{",
      "    a %= MOD;",
      "    if (a == 0)",
      "        return 0;",
      "    ll product = 1;",
      "    while (b > 0)",
      "    {",
      "        if (b & 1)",
      "        {",
      "            product *= a;",
      "            product %= MOD;",
      "            --b;",
      "        }",
      "        a *= a;",
      "        a %= MOD;",
      "        b /= 2;",
      "    }",
      "    return product;",
      "}",
      ""
    ],
    "description": "fast_pow"
  },
  "Deci to Base K": {
    "prefix": "to_base_k",
    "body": [
      "char reVal(int num)",
      "{",
      "    if (num >= 0 && num <= 9)",
      "        return (char)(num + '0');",
      "    else",
      "        return (char)(num - 10 + 'A');",
      "}",
      "",
      "void strev(char *str)",
      "{",
      "    int len = strlen(str);",
      "    int i;",
      "    for (i = 0; i < len / 2; i++)",
      "    {",
      "        char temp = str[i];",
      "        str[i] = str[len - i - 1];",
      "        str[len - i - 1] = temp;",
      "    }",
      "}",
      "",
      "char *fromDeci(char res[100], ll base, ll inputNum)",
      "{",
      "    int index = 0;",
      "",
      "    while (inputNum > 0)",
      "    {",
      "        res[index++] = reVal(inputNum % base);",
      "        inputNum /= base;",
      "    }",
      "    res[index] = '\\0';",
      "",
      "    strev(res);",
      "",
      "    return res;",
      "}",
      ""
    ],
    "description": "Deci to Base K"
  },
  "seg_tree": {
    "prefix": "seg_tree",
    "body": [
      "struct segTree",
      "{",
      "    int size;",
      "    vector<long long> data;",
      "    void init(int n)",
      "    {",
      "        size = 1;",
      "        while (size < n)",
      "            size *= 2;",
      "        data.assign(2 * size, 0LL); // asigin it to the cloeset poewr of two",
      "    }",
      "    void set(int i, long long value, int node, int beginSeg, int endSeg)",
      "    {",
      "        if (beginSeg == endSeg)",
      "        {",
      "            data[node] = value;",
      "            return;",
      "        }",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        if (i <= mid)",
      "            set(i, value, 2 * node, beginSeg, mid);",
      "        else",
      "            set(i, value, 2 * node + 1, mid + 1, endSeg);",
      "",
      "        data[node] = (data[2 * node] + data[2 * node + 1]);",
      "    }",
      "",
      "    long long sum(int left, int right, int node, int beginSeg, int endSeg)",
      "    {",
      "        if (beginSeg > right || left > endSeg)",
      "            return 0;",
      "",
      "        if (beginSeg >= left && endSeg <= right)",
      "            return data[node];",
      "",
      "        int mid = (beginSeg + endSeg) / 2;",
      "        long long sum1 = this->sum(left, right, 2 * node, beginSeg, mid);",
      "        long long sum2 = this->sum(left, right, 2 * node + 1, mid + 1, endSeg);",
      "",
      "        return (sum1 + sum2);",
      "    }",
      "    long long sum(int left, int right)",
      "    {",
      "",
      "        return sum(left, right, 1, 1, size);",
      "    }",
      "    void set(int i, long long value)",
      "    {",
      "        set(i, value, 1, 1, size);",
      "    }",
      "};",
      ""
    ],
    "description": "seg_tree"
  },
  "deq1": {
    "prefix": "deq_out",
    "body": [
      "template <typename T>",
      "ostream &operator<<(ostream &out, deque<T> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "        out << outto[i] << \" \";",
      "    return out;",
      "}"
    ],
    "description": ""
  },
  "deq2": {
    "prefix": "deq_in",
    "body": [
      "template <typename T>",
      "istream &operator>>(istream &in, deque<T> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        in >> into[i];",
      "",
      "    return in;",
      "}"
    ],
    "description": ""
  },
  "pairs_in": {
    "prefix": "pairs_in",
    "body": [
      "template <typename T, typename S>",
      "istream &operator>>(istream &in, vector<pair<T, S>> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        in >> into[i].first >> into[i].second;",
      "",
      "    return in;",
      "}"
    ],
    "description": "pairs_in"
  },
  "pairs_out": {
    "prefix": "pairs_out",
    "body": [
      "",
      "template <typename T, typename S>",
      "ostream &operator<<(ostream &out, vector<pair<T, S>> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "        out << outto[i].first << \"->\" << outto[i].second << ' ';",
      "    return out;",
      "}"
    ],
    "description": "pairs_out"
  },
  "de": {
    "prefix": "debug",
    "body": ["debug {", "  $1", "}"]
  },
  "use_2d": {
    "prefix": "use_2d",
    "body": [
      "template <typename T>",
      "istream &operator>>(istream &in, vector<vector<T>> &into)",
      "{",
      "    for (ll i = 0; i < size(into); i++)",
      "        for (ll j = 0; j < size(into[i]); j++)",
      "            in >> into[i][j];",
      "",
      "    return in;",
      "}",
      "template <typename T>",
      "ostream &operator<<(ostream &out, vector<vector<T>> &outto)",
      "{",
      "    for (ll i = 0; i < size(outto); i++)",
      "    {",
      "        for (int j = 0; j < outto[i].size(); j++)",
      "        {",
      "            out << outto[i][j] << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "    return out;",
      "}"
    ],
    "description": "use_2d"
  },
  "DSU": {
    "prefix": "dsu",
    "body": [
      "template <typename T = int, int Base = 1>",
      "struct DSU",
      "{",
      "",
      "    vector<T> parent, Gsize;",
      "",
      "    DSU(int MaxNodes)",
      "    {",
      "        parent = Gsize = vector<T>(MaxNodes + 5);",
      "        for (int i = Base; i <= MaxNodes; i++)",
      "            parent[i] = i, Gsize[i] = 1;",
      "    }",
      "",
      "    T find_leader(int node)",
      "    {",
      "        return parent[node] = (parent[node] == node ? node : find_leader(parent[node]));",
      "    }",
      "",
      "    bool is_same_sets(int u, int v)",
      "    {",
      "        return find_leader(u) == find_leader(v);",
      "    }",
      "",
      "    void union_sets(int u, int v)",
      "    {",
      "        int leader_u = find_leader(u), leader_v = find_leader(v);",
      "        if (leader_u == leader_v)",
      "            return;",
      "        if (Gsize[leader_u] < Gsize[leader_v])",
      "            swap(leader_u, leader_v);",
      "        Gsize[leader_u] += Gsize[leader_v], parent[leader_v] = leader_u;",
      "    }",
      "",
      "    int get_size(int u)",
      "    {",
      "        return Gsize[find_leader(u)];",
      "    }",
      "};"
    ],
    "description": "DSU"
  },
  "str_sub": {
    "prefix": "str_sub",
    "body": [
      "struct Str_Sub_Digit_Res",
      "{",
      "    int r;",
      "    int b;",
      "};",
      "struct Str_Sub_Digit_Res subDigits(char c1, char c2, int b)",
      "{",
      "    Str_Sub_Digit_Res res;",
      "    int d1 = c1 - '0';",
      "    int d2 = c2 - '0';",
      "    int n = d1 - d2 - b;",
      "    if (n >= 0)",
      "    {",
      "        res.r = n;",
      "        res.b = 0;",
      "    }",
      "    else",
      "    {",
      "        res.r = n + 10;",
      "        res.b = 1;",
      "    }",
      "    return res;",
      "}",
      "string stripLeadingZero(string s)",
      "{",
      "    string new_s = s;",
      "    int i = 0;",
      "    while (i < s.size() && s[i] == '0')",
      "        i++;",
      "    if (i == s.size())",
      "        return \"0\";",
      "    return s.substr(i);",
      "}",
      "string str_sub(string a, string b)",
      "{",
      "    int borrow = 0;",
      "    string res;",
      "    for (int i = a.size() - 1; i >= 0; i--)",
      "    {",
      "        struct Str_Sub_Digit_Res t = subDigits(a[i], b[i], borrow);",
      "        borrow = t.b;   ",
      "        res = char('0' + t.r) + res;",
      "    }",
      "",
      "    return stripLeadingZero(res);",
      "}"
    ],
    "description": "str_sub"
  },
  "snoob": {
    "prefix": "snoob",
    "body": [
      "uint64_t snoob(uint64_t x)",
      "{",
      "    uint64_t smallest, ripple, ones;",
      "    smallest = x & -x;",
      "    ripple = x + smallest;",
      "    ones = x ^ ripple;",
      "    ones = (ones >> 2) / smallest;",
      "",
      "    rt(ripple | ones);",
      "}"
    ],
    "description": ""
  },
  "extended_ecluid": {
    "prefix": "extended_ecluid",
    "body": [
      "long long extended_ecluid(long long a, long long b, long long &x, long long &y)",
      "{",
      "    if (b == 0)",
      "    {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "    }",
      "    long long x1, y1;",
      "    long long d = extended_ecluid(b, a % b, x1, y1);",
      "    x = y1;",
      "    y = x1 - y1 * (a / b);",
      "    return d;",
      "}"
    ],
    "description": "extended_ecluid"
  },
  "mx_subseq_sum": {
    "prefix": "mx_subseq_sum",
    "body": [
      "ll mx_subseq_sum(vec &nums)",
      "{",
      "    ll cur = 0;",
      "    ll mx = -OOO;",
      "",
      "    for (int i = 0; i < nums.size(); i++)",
      "    {",
      "        cur += nums[i];",
      "        if (cur <= 0)",
      "            cur = 0;",
      "        mx = max(cur, mx);",
      "    }",
      "",
      "    rt mx;",
      "}"
    ],
    "description": "mx_subseq_sum"
  },
  "nCr": {
    "prefix": "nCk",
    "body": [
      "unsigned long long nCk(unsigned long long n,long long  unsigned k )",
      "{",
      "    if (k > n) return 0;",
      "    if (k * 2 > n) k = n-k;",
      "    if (k == 0) return 1;",
      "",
      "    unsigned long long result = n;",
      "    for( long long i = 2; i <= k; ++i ) {",
      "        result *= (n-i+1);",
      "        result /= i;",
      "    }",
      "    return result;",
      "}"
    ],
    "description": "nCr"
  },
  "nCr": {
    "prefix": "nCr",
    "body": [
      "ll fast_pow(ll a, ll b)",
      "{",
      "    a %= MOD;",
      "    if (a == 0)",
      "        return 0;",
      "    ll product = 1;",
      "    while (b > 0)",
      "    {",
      "        if (b & 1)",
      "        {",
      "            product *= a;",
      "            product %= MOD;",
      "            --b;",
      "        }",
      "        a *= a;",
      "        a %= MOD;",
      "        b /= 2;",
      "    }",
      "    return product;",
      "}",
      "vec factorial(1e6);",
      "ll modular_inverse(ll n)",
      "{",
      "    return fast_pow(n, MOD - 2);",
      "}",
      "",
      "ll nCr(ll n, ll k)",
      "{",
      "",
      "    if (n == k || !k)",
      "        return 1;",
      "    return (factorial[n] * modular_inverse(factorial[k] * factorial[n - k])) % MOD;",
      "}",
      " ll cur = 1;",
      "    for (ll i = 1; i < 1e6; i++)",
      "    {",
      "        cur *= i;",
      "        cur %= MOD;",
      "        factorial[i] = cur;",
      "    }"
    ],
    "description": "nCr"
  },
  "factors": {
    "prefix": "factors",
    "body": [
      "",
      "vec factors(ll n)",
      "{",
      "    vec res;",
      "    for (ll x = 1; x * x <= n; x++)",
      "    {",
      "        if (n % x == 0)",
      "        {",
      "            if (n / x != x)",
      "                res.push_back(n / x);",
      "            res.push_back(x);",
      "        }",
      "    }",
      "",
      "    return res;",
      "}"
    ],
    "description": "factors"
  },
  "2d_sliding_window": {
    "prefix": "2d_sliding_window",
    "body": [
      "class MinQ",
      "{",
      "public:",
      "    queue<int> q;",
      "    deque<int> dq;",
      "    void push(int x)",
      "    {",
      "        q.push(x);",
      "        while (!dq.empty() && x < dq.back())",
      "        {",
      "            dq.pop_back();",
      "        }",
      "        dq.push_back(x);",
      "    }",
      "    void pop()",
      "    {",
      "        if (q.front() == dq.front())",
      "        {",
      "            q.pop();",
      "            dq.pop_front();",
      "        }",
      "        else",
      "            q.pop();",
      "    }",
      "    int min()",
      "    {",
      "        return dq.front();",
      "    }",
      "};",
      "",
      "vector<int> minSliding_1d_Window(vector<int> &v, int k)",
      "{",
      "    MinQ q;",
      "    int n = v.size();",
      "    vector<int> ans;",
      "    for (int i = 0; i < k; i++)",
      "    {",
      "        q.push(v[i]);",
      "    }",
      "    for (int i = k; i < n; i++)",
      "    {",
      "        ans.push_back(q.min());",
      "        q.pop();",
      "        q.push(v[i]);",
      "    }",
      "    ans.push_back(q.min());",
      "    return ans;",
      "}",
      "vector<vector<int>> minSliding_2d_Window(vector<vector<int>> v, int k)",
      "{",
      "",
      "    int n = v.size();",
      "    int m = v[0].size();",
      "",
      "    // caclulting sliding window horizontally",
      "    vector<vector<int>> horizontal;",
      "    for (int i = 0; i < v.size(); i++)",
      "    {",
      "        vector<int> part = minSliding_1d_Window(v[i], k);",
      "        horizontal.push_back(part);",
      "    }",
      "",
      "    vector<vector<int>> final(n - k + 1, vector<int>(m - k + 1, -3));",
      "    int c = 0;",
      "",
      "    // calculationg sliding window vertically",
      "    for (int j = 0; j < horizontal[0].size(); j++)",
      "    {",
      "        vector<int> v;",
      "        for (int i = 0; i < horizontal.size(); i++)",
      "        {",
      "            v.push_back(horizontal[i][j]);",
      "        }",
      "        vector<int> tmp = minSliding_1d_Window(v, k);",
      "",
      "        // pushing the result in our resultant matrix",
      "        for (int index = 0; index < n - k + 1; index++)",
      "        {",
      "            final[index][c] = tmp[index];",
      "        }",
      "        c++;",
      "    }",
      "",
      "    // return final matrix",
      "    return final;",
      "}"
    ],
    "description": "2d_sliding_window"
  }
}
